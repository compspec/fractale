from fractale.agent.base import Agent
import fractale.agent.build.prompts as prompts
from fractale.agent.context import get_context

import fractale.utils as utils
import argparse

from rich import print
from rich.panel import Panel
from rich.syntax import Syntax

import re
import os
import sys
import shutil
import tempfile
import subprocess
import textwrap

# regular expression in case LLM does not follow my instructions!
dockerfile_pattern = r"```(?:dockerfile)?\n(.*?)```"

class BuildAgent(Agent):
    """
    Builder agent.
    """

    name = "build"
    description = "builder agent"

    def add_arguments(self, subparser):
        """
        Add arguments for the plugin to show up in argparse
        """
        build = subparser.add_parser(
            self.name,
            formatter_class=argparse.RawTextHelpFormatter,
            description=self.description,
        )
        # Ensure these are namespaced to your plugin
        build.add_argument(
            "--outfile",
            help="Output file to write Dockerfile to (if not specified, only will print)",
        )
        build.add_argument(
            "--container",
            help="Container unique resource identifier (defaults to application if not set)",
        )
        build.add_argument(
            "application",
            help="Application to build.",
        )
        build.add_argument(
            "--environment",
            help="Environment description to build for (defaults to generic)",
        )
        # This is just to identify the agent
        build.add_argument(
            "--agent-name",
            default=self.name,
            dest="agent_name",
        )

    def run(self, context):
        """
        Run the agent.      

        TODO: get working here
        Then think about how to move between steps. We will want to be able to
        get initial variables from a plan for redoing steps.  OR keep the last
        state of running it.
        """
        import google.generativeai as genai

        # Create or get global context
        context = get_context(context)
        
        # Init attempts. Each agent has an internal counter for total attempts
        self.attempts = self.attempts or 0

        # Map context into needed arguments and validate
        environment = context.get('environment', "generic cloud environment")        
        application = context.get('application', required=True)

        # These are optional if we are doing a follow up build
        error_message = context.get('error_message')
        dockerfile = context.get('dockerfile')
        
        try:
            genai.configure(api_key=os.environ["GEMINI_API_KEY"])
        except KeyError:
            sys.exit("ERROR: GEMINI_API_KEY environment variable not set.")

        # This will either generate fresh or rebuild erroneous Dockerfile
        # We don't return the dockerfile because it is updated in the context
        context.dockerfile = self.generate_dockerfile(
            context.application, context.environment, error_message=error_message, dockerfile=dockerfile
        )
        print(Panel(context.dockerfile, title="[green]Dockerfile[/green]", border_style="green"))

        # Build it! We might want to only allow a certain number of retries or incremental changes.
        return_code, output = self.build(
            context.dockerfile,
            image_name=context.container or self.generate_name(application),
        )
        if return_code == 0:
            print(
                Panel(
                    f"[bold green]✅ Build complete in {self.attempts} attempts[/bold green]",
                    title="Success",
                    border_style="green",
                )
            )
        else:
            print(
                Panel(
                    "[bold red]❌ Build failed[/bold red]", title="Build Status", border_style="red"
                )
            )
            self.attempts += 1
            print("\n[bold cyan] Requesting Correction from Build Agent[/bold cyan]")

            # Update the context with error message
            context.error_message = output
            return self.run(context)

        # Add generation line
        context.dockerfile += "\n# Generated by fractale build agent"
        self.print_dockerfile(context.dockerfile)
        if context.outfile:
            utils.write_file(dockerfile, context.outfile)
        return context.dockerfile

    def print_dockerfile(self, dockerfile):
        """
        Print Dockerfile with highlighted Syntax
        """
        highlighted_syntax = Syntax(dockerfile, "docker", theme="monokai", line_numbers=True)
        print(
            Panel(
                highlighted_syntax,
                title="[bold green]✅ Final Dockerfile[/bold green]",
                border_style="green",
                expand=True,
            )
        )

    def generate_name(self, name):
        """
        If no container URI provided, generate a name based on application.
        """
        # Replace invalid characters with hyphens
        name = re.sub(r"[^a-zA-Z0-9_.-]", "-", name)

        # First character needs to be alphanumeric
        if not name[0].isalnum():
            name = "c" + name

        # Remove leading/trailing separators if they exist
        name = re.sub(r"^[._-]*", "", name)
        name = re.sub(r"[._-]*$", "", name)

        # Truncate to a maximum of 63 characters and strip crap
        name = name[:63].strip("-")

        # Ensure it's at least 2 characters long (add a 'c' if it's too short)
        if len(name) < 2:
            name = name + "c"
        return name

    def build(self, dockerfile, image_name):
        """
        Build the Dockerfile! Yolo!
        """
        # Not sure if this can happen, assume it can
        if not dockerfile:
            raise ValueError("No dockerfile content provided.")

        build_dir = tempfile.mkdtemp()
        print(f"[dim]Created temporary build context: {build_dir}[/dim]")

        # Write the Dockerfile to the temporary directory
        utils.write_file(dockerfile, os.path.join(build_dir, "Dockerfile"))
        print(
            Panel(
                f"Attempt {self.attempts} to build image: [bold cyan]{image_name}[/bold cyan]",
                title="[blue]Docker Build[/blue]",
                border_style="blue",
            )
        )

        # Run the build process using the temporary directory as context
        p = subprocess.run(
            ["docker", "build", "-t", image_name, "."],
            capture_output=True,
            text=True,
            cwd=build_dir,
            check=False,
        )
        # Clean up after we finish
        shutil.rmtree(build_dir, ignore_errors=True)
        return (p.returncode, p.stdout + p.stderr)

    def generate_dockerfile(
        self,
        application,
        environment,
        dockerfile=None,
        error_message=None,
    ):
        """
        Generates or refines a Dockerfile using the Gemini API.
        """
        import google.generativeai as genai

        model = genai.GenerativeModel("gemini-2.5-pro")

        # If a previous dockerfile failed at runtime, we are tweaking it
        # Otherwise we prepare a new request.
        if dockerfile and error_message:
            prompt = prompts.get_rebuild_prompt(application, environment, dockerfile, error_message)
        else:
            prompt = prompts.get_build_prompt(application, environment)

        print("Sending build prompt to Gemini...")
        print(textwrap.indent(prompt, "> ", predicate=lambda _: True))

        response = model.generate_content(prompt)
        print("Received Dockerfile response from Gemini...")

        # Try to remove Dockerfile from code block
        try:
            content = response.text.strip()
            if content.startswith("```dockerfile"):
                content = content[len("```dockerfile") :]
            if content.startswith("```"):
                content = content[len("```") :]
            if content.endswith("```"):
                content = content[: -len("```")]

            # If we are getting commentary...
            match = re.search(dockerfile_pattern, content, re.DOTALL)
            if match:
                return match.group(1).strip()
            return content.strip()
        except Exception as e:
            sys.exit(f"Error parsing response from Gemini: {e}\n{response.text}")
